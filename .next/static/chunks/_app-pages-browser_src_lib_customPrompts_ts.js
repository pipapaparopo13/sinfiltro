"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_customPrompts_ts"],{

/***/ "(app-pages-browser)/./src/lib/customPrompts.ts":
/*!**********************************!*\
  !*** ./src/lib/customPrompts.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLibrary: function() { return /* binding */ createLibrary; },\n/* harmony export */   deleteLibrary: function() { return /* binding */ deleteLibrary; },\n/* harmony export */   generateLibraryCode: function() { return /* binding */ generateLibraryCode; },\n/* harmony export */   getLibrary: function() { return /* binding */ getLibrary; },\n/* harmony export */   getLocalLibraries: function() { return /* binding */ getLocalLibraries; },\n/* harmony export */   incrementPlayCount: function() { return /* binding */ incrementPlayCount; },\n/* harmony export */   removeLibraryFromLocal: function() { return /* binding */ removeLibraryFromLocal; },\n/* harmony export */   saveLibraryToLocal: function() { return /* binding */ saveLibraryToLocal; },\n/* harmony export */   updateLibrary: function() { return /* binding */ updateLibrary; },\n/* harmony export */   verifyLibraryPassword: function() { return /* binding */ verifyLibraryPassword; }\n/* harmony export */ });\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n\n// Simple hash function (not cryptographic, just for basic protection)\nfunction simpleHash(str) {\n    let hash = 0;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash;\n    }\n    return Math.abs(hash).toString(36);\n}\n// Generate a random library code\nfunction generateLibraryCode() {\n    const chars = \"ABCDEFGHJKLMNPQRSTUVWXYZ23456789\"; // Evitamos caracteres confusos\n    let code = \"\";\n    for(let i = 0; i < 6; i++){\n        code += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return code;\n}\n// Create a new custom library\nasync function createLibrary(name, prompts, password) {\n    try {\n        const code = generateLibraryCode();\n        const library = {\n            id: code,\n            name: name.trim(),\n            passwordHash: password ? simpleHash(password) : undefined,\n            createdAt: Date.now(),\n            updatedAt: Date.now(),\n            prompts: prompts.filter((p)=>p.trim().length > 0),\n            playCount: 0\n        };\n        await (0,_firebase__WEBPACK_IMPORTED_MODULE_0__.set)((0,_firebase__WEBPACK_IMPORTED_MODULE_0__.dbRef)(\"libraries/\".concat(code)), library);\n        // Save to localStorage for easy access\n        saveLibraryToLocal(code, name);\n        return {\n            success: true,\n            code\n        };\n    } catch (error) {\n        console.error(\"Error creating library:\", error);\n        return {\n            success: false,\n            error: \"Error al crear la biblioteca\"\n        };\n    }\n}\n// Get a library by code\nasync function getLibrary(code) {\n    try {\n        const snapshot = await (0,_firebase__WEBPACK_IMPORTED_MODULE_0__.get)((0,_firebase__WEBPACK_IMPORTED_MODULE_0__.dbRef)(\"libraries/\".concat(code.toUpperCase())));\n        if (snapshot.exists()) {\n            return snapshot.val();\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting library:\", error);\n        return null;\n    }\n}\n// Update a library (requires password if set)\nasync function updateLibrary(code, updates, password) {\n    try {\n        const library = await getLibrary(code);\n        if (!library) {\n            return {\n                success: false,\n                error: \"Biblioteca no encontrada\"\n            };\n        }\n        // Check password if library is protected\n        if (library.passwordHash) {\n            if (!password || simpleHash(password) !== library.passwordHash) {\n                return {\n                    success: false,\n                    error: \"Contrase\\xf1a incorrecta\"\n                };\n            }\n        }\n        const updateData = {\n            updatedAt: Date.now()\n        };\n        if (updates.name) updateData.name = updates.name.trim();\n        if (updates.prompts) updateData.prompts = updates.prompts.filter((p)=>p.trim().length > 0);\n        await (0,_firebase__WEBPACK_IMPORTED_MODULE_0__.update)((0,_firebase__WEBPACK_IMPORTED_MODULE_0__.dbRef)(\"libraries/\".concat(code.toUpperCase())), updateData);\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error(\"Error updating library:\", error);\n        return {\n            success: false,\n            error: \"Error al actualizar la biblioteca\"\n        };\n    }\n}\n// Increment play count\nasync function incrementPlayCount(code) {\n    try {\n        const library = await getLibrary(code);\n        if (library) {\n            await (0,_firebase__WEBPACK_IMPORTED_MODULE_0__.update)((0,_firebase__WEBPACK_IMPORTED_MODULE_0__.dbRef)(\"libraries/\".concat(code.toUpperCase())), {\n                playCount: (library.playCount || 0) + 1\n            });\n        }\n    } catch (error) {\n        console.error(\"Error incrementing play count:\", error);\n    }\n}\n// Delete a library (requires password)\nasync function deleteLibrary(code, password) {\n    try {\n        const library = await getLibrary(code);\n        if (!library) {\n            return {\n                success: false,\n                error: \"Biblioteca no encontrada\"\n            };\n        }\n        if (library.passwordHash) {\n            if (!password || simpleHash(password) !== library.passwordHash) {\n                return {\n                    success: false,\n                    error: \"Contrase\\xf1a incorrecta\"\n                };\n            }\n        }\n        await (0,_firebase__WEBPACK_IMPORTED_MODULE_0__.remove)((0,_firebase__WEBPACK_IMPORTED_MODULE_0__.dbRef)(\"libraries/\".concat(code.toUpperCase())));\n        removeLibraryFromLocal(code);\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error(\"Error deleting library:\", error);\n        return {\n            success: false,\n            error: \"Error al eliminar la biblioteca\"\n        };\n    }\n}\n// Local storage helpers\nconst LOCAL_STORAGE_KEY = \"quiplash_my_libraries\";\nfunction getLocalLibraries() {\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(LOCAL_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch (e) {\n        return [];\n    }\n}\nfunction saveLibraryToLocal(code, name) {\n    if (false) {}\n    try {\n        const libraries = getLocalLibraries().filter((l)=>l.code !== code.toUpperCase());\n        libraries.unshift({\n            code: code.toUpperCase(),\n            name,\n            addedAt: Date.now()\n        });\n        // Keep only the last 10 libraries\n        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(libraries.slice(0, 10)));\n    } catch (error) {\n        console.error(\"Error saving to local storage:\", error);\n    }\n}\nfunction removeLibraryFromLocal(code) {\n    if (false) {}\n    try {\n        const libraries = getLocalLibraries().filter((l)=>l.code !== code.toUpperCase());\n        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(libraries));\n    } catch (error) {\n        console.error(\"Error removing from local storage:\", error);\n    }\n}\n// Verify password for a library\nasync function verifyLibraryPassword(code, password) {\n    const library = await getLibrary(code);\n    if (!library) return false;\n    if (!library.passwordHash) return true; // No password required\n    return simpleHash(password) === library.passwordHash;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY3VzdG9tUHJvbXB0cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE2RDtBQWE3RCxzRUFBc0U7QUFDdEUsU0FBU0ssV0FBV0MsR0FBVztJQUMzQixJQUFJQyxPQUFPO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLElBQUlHLE1BQU0sRUFBRUQsSUFBSztRQUNqQyxNQUFNRSxPQUFPSixJQUFJSyxVQUFVLENBQUNIO1FBQzVCRCxPQUFPLENBQUVBLFFBQVEsS0FBS0EsT0FBUUc7UUFDOUJILE9BQU9BLE9BQU9BO0lBQ2xCO0lBQ0EsT0FBT0ssS0FBS0MsR0FBRyxDQUFDTixNQUFNTyxRQUFRLENBQUM7QUFDbkM7QUFFQSxpQ0FBaUM7QUFDMUIsU0FBU0M7SUFDWixNQUFNQyxRQUFRLG9DQUFvQywrQkFBK0I7SUFDakYsSUFBSUMsT0FBTztJQUNYLElBQUssSUFBSVQsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDeEJTLFFBQVFELE1BQU1FLE1BQU0sQ0FBQ04sS0FBS08sS0FBSyxDQUFDUCxLQUFLUSxNQUFNLEtBQUtKLE1BQU1QLE1BQU07SUFDaEU7SUFDQSxPQUFPUTtBQUNYO0FBRUEsOEJBQThCO0FBQ3ZCLGVBQWVJLGNBQ2xCQyxJQUFZLEVBQ1pDLE9BQWlCLEVBQ2pCQyxRQUFpQjtJQUVqQixJQUFJO1FBQ0EsTUFBTVAsT0FBT0Y7UUFDYixNQUFNVSxVQUF5QjtZQUMzQkMsSUFBSVQ7WUFDSkssTUFBTUEsS0FBS0ssSUFBSTtZQUNmQyxjQUFjSixXQUFXbkIsV0FBV21CLFlBQVlLO1lBQ2hEQyxXQUFXQyxLQUFLQyxHQUFHO1lBQ25CQyxXQUFXRixLQUFLQyxHQUFHO1lBQ25CVCxTQUFTQSxRQUFRVyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVSLElBQUksR0FBR2xCLE1BQU0sR0FBRztZQUMvQzJCLFdBQVc7UUFDZjtRQUVBLE1BQU1uQyw4Q0FBR0EsQ0FBQ0Qs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S0EsRUFBRTNDLElBQUksS0FBS0EsS0FBSzBCLFdBQVc7UUFDN0VZLGFBQWFRLE9BQU8sQ0FBQ1gsbUJBQW1CSyxLQUFLTyxTQUFTLENBQUNMO0lBQzNELEVBQUUsT0FBT3BCLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLHNDQUFzQ0E7SUFDeEQ7QUFDSjtBQUVBLGdDQUFnQztBQUN6QixlQUFlMkIsc0JBQXNCakQsSUFBWSxFQUFFTyxRQUFnQjtJQUN0RSxNQUFNQyxVQUFVLE1BQU1nQixXQUFXeEI7SUFDakMsSUFBSSxDQUFDUSxTQUFTLE9BQU87SUFDckIsSUFBSSxDQUFDQSxRQUFRRyxZQUFZLEVBQUUsT0FBTyxNQUFNLHVCQUF1QjtJQUMvRCxPQUFPdkIsV0FBV21CLGNBQWNDLFFBQVFHLFlBQVk7QUFDeEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9jdXN0b21Qcm9tcHRzLnRzP2VkODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGJSZWYsIHNldCwgZ2V0LCB1cGRhdGUsIHJlbW92ZSB9IGZyb20gJy4vZmlyZWJhc2UnO1xuaW1wb3J0IHsgZ2V0RGF0YWJhc2UsIHJlZiwgY2hpbGQgfSBmcm9tICdmaXJlYmFzZS9kYXRhYmFzZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tTGlicmFyeSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcGFzc3dvcmRIYXNoPzogc3RyaW5nOyAvLyBTaW1wbGUgaGFzaCBmb3IgZWRpdGluZyBwcm90ZWN0aW9uXG4gICAgY3JlYXRlZEF0OiBudW1iZXI7XG4gICAgdXBkYXRlZEF0OiBudW1iZXI7XG4gICAgcHJvbXB0czogc3RyaW5nW107XG4gICAgcGxheUNvdW50OiBudW1iZXI7XG59XG5cbi8vIFNpbXBsZSBoYXNoIGZ1bmN0aW9uIChub3QgY3J5cHRvZ3JhcGhpYywganVzdCBmb3IgYmFzaWMgcHJvdGVjdGlvbilcbmZ1bmN0aW9uIHNpbXBsZUhhc2goc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCBoYXNoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGNoYXI7XG4gICAgICAgIGhhc2ggPSBoYXNoICYgaGFzaDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguYWJzKGhhc2gpLnRvU3RyaW5nKDM2KTtcbn1cblxuLy8gR2VuZXJhdGUgYSByYW5kb20gbGlicmFyeSBjb2RlXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVMaWJyYXJ5Q29kZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISktMTU5QUVJTVFVWV1hZWjIzNDU2Nzg5JzsgLy8gRXZpdGFtb3MgY2FyYWN0ZXJlcyBjb25mdXNvc1xuICAgIGxldCBjb2RlID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgY29kZSArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlO1xufVxuXG4vLyBDcmVhdGUgYSBuZXcgY3VzdG9tIGxpYnJhcnlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVMaWJyYXJ5KFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBwcm9tcHRzOiBzdHJpbmdbXSxcbiAgICBwYXNzd29yZD86IHN0cmluZ1xuKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGNvZGU/OiBzdHJpbmc7IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjb2RlID0gZ2VuZXJhdGVMaWJyYXJ5Q29kZSgpO1xuICAgICAgICBjb25zdCBsaWJyYXJ5OiBDdXN0b21MaWJyYXJ5ID0ge1xuICAgICAgICAgICAgaWQ6IGNvZGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLnRyaW0oKSxcbiAgICAgICAgICAgIHBhc3N3b3JkSGFzaDogcGFzc3dvcmQgPyBzaW1wbGVIYXNoKHBhc3N3b3JkKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHByb21wdHM6IHByb21wdHMuZmlsdGVyKHAgPT4gcC50cmltKCkubGVuZ3RoID4gMCksXG4gICAgICAgICAgICBwbGF5Q291bnQ6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBhd2FpdCBzZXQoZGJSZWYoYGxpYnJhcmllcy8ke2NvZGV9YCksIGxpYnJhcnkpO1xuXG4gICAgICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlIGZvciBlYXN5IGFjY2Vzc1xuICAgICAgICBzYXZlTGlicmFyeVRvTG9jYWwoY29kZSwgbmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgY29kZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGxpYnJhcnk6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdFcnJvciBhbCBjcmVhciBsYSBiaWJsaW90ZWNhJyB9O1xuICAgIH1cbn1cblxuLy8gR2V0IGEgbGlicmFyeSBieSBjb2RlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TGlicmFyeShjb2RlOiBzdHJpbmcpOiBQcm9taXNlPEN1c3RvbUxpYnJhcnkgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXQoZGJSZWYoYGxpYnJhcmllcy8ke2NvZGUudG9VcHBlckNhc2UoKX1gKSk7XG4gICAgICAgIGlmIChzbmFwc2hvdC5leGlzdHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNuYXBzaG90LnZhbCgpIGFzIEN1c3RvbUxpYnJhcnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBsaWJyYXJ5OicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vLyBVcGRhdGUgYSBsaWJyYXJ5IChyZXF1aXJlcyBwYXNzd29yZCBpZiBzZXQpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlTGlicmFyeShcbiAgICBjb2RlOiBzdHJpbmcsXG4gICAgdXBkYXRlczogeyBuYW1lPzogc3RyaW5nOyBwcm9tcHRzPzogc3RyaW5nW10gfSxcbiAgICBwYXNzd29yZD86IHN0cmluZ1xuKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBsaWJyYXJ5ID0gYXdhaXQgZ2V0TGlicmFyeShjb2RlKTtcbiAgICAgICAgaWYgKCFsaWJyYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdCaWJsaW90ZWNhIG5vIGVuY29udHJhZGEnIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBwYXNzd29yZCBpZiBsaWJyYXJ5IGlzIHByb3RlY3RlZFxuICAgICAgICBpZiAobGlicmFyeS5wYXNzd29yZEhhc2gpIHtcbiAgICAgICAgICAgIGlmICghcGFzc3dvcmQgfHwgc2ltcGxlSGFzaChwYXNzd29yZCkgIT09IGxpYnJhcnkucGFzc3dvcmRIYXNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnQ29udHJhc2XDsWEgaW5jb3JyZWN0YScgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwZGF0ZURhdGE6IGFueSA9IHsgdXBkYXRlZEF0OiBEYXRlLm5vdygpIH07XG4gICAgICAgIGlmICh1cGRhdGVzLm5hbWUpIHVwZGF0ZURhdGEubmFtZSA9IHVwZGF0ZXMubmFtZS50cmltKCk7XG4gICAgICAgIGlmICh1cGRhdGVzLnByb21wdHMpIHVwZGF0ZURhdGEucHJvbXB0cyA9IHVwZGF0ZXMucHJvbXB0cy5maWx0ZXIocCA9PiBwLnRyaW0oKS5sZW5ndGggPiAwKTtcblxuICAgICAgICBhd2FpdCB1cGRhdGUoZGJSZWYoYGxpYnJhcmllcy8ke2NvZGUudG9VcHBlckNhc2UoKX1gKSwgdXBkYXRlRGF0YSk7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBsaWJyYXJ5OicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRXJyb3IgYWwgYWN0dWFsaXphciBsYSBiaWJsaW90ZWNhJyB9O1xuICAgIH1cbn1cblxuLy8gSW5jcmVtZW50IHBsYXkgY291bnRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbmNyZW1lbnRQbGF5Q291bnQoY29kZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbGlicmFyeSA9IGF3YWl0IGdldExpYnJhcnkoY29kZSk7XG4gICAgICAgIGlmIChsaWJyYXJ5KSB7XG4gICAgICAgICAgICBhd2FpdCB1cGRhdGUoZGJSZWYoYGxpYnJhcmllcy8ke2NvZGUudG9VcHBlckNhc2UoKX1gKSwge1xuICAgICAgICAgICAgICAgIHBsYXlDb3VudDogKGxpYnJhcnkucGxheUNvdW50IHx8IDApICsgMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbmNyZW1lbnRpbmcgcGxheSBjb3VudDonLCBlcnJvcik7XG4gICAgfVxufVxuXG4vLyBEZWxldGUgYSBsaWJyYXJ5IChyZXF1aXJlcyBwYXNzd29yZClcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVMaWJyYXJ5KFxuICAgIGNvZGU6IHN0cmluZyxcbiAgICBwYXNzd29yZD86IHN0cmluZ1xuKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBsaWJyYXJ5ID0gYXdhaXQgZ2V0TGlicmFyeShjb2RlKTtcbiAgICAgICAgaWYgKCFsaWJyYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdCaWJsaW90ZWNhIG5vIGVuY29udHJhZGEnIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlicmFyeS5wYXNzd29yZEhhc2gpIHtcbiAgICAgICAgICAgIGlmICghcGFzc3dvcmQgfHwgc2ltcGxlSGFzaChwYXNzd29yZCkgIT09IGxpYnJhcnkucGFzc3dvcmRIYXNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnQ29udHJhc2XDsWEgaW5jb3JyZWN0YScgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHJlbW92ZShkYlJlZihgbGlicmFyaWVzLyR7Y29kZS50b1VwcGVyQ2FzZSgpfWApKTtcbiAgICAgICAgcmVtb3ZlTGlicmFyeUZyb21Mb2NhbChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGxpYnJhcnk6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdFcnJvciBhbCBlbGltaW5hciBsYSBiaWJsaW90ZWNhJyB9O1xuICAgIH1cbn1cblxuLy8gTG9jYWwgc3RvcmFnZSBoZWxwZXJzXG5jb25zdCBMT0NBTF9TVE9SQUdFX0tFWSA9ICdxdWlwbGFzaF9teV9saWJyYXJpZXMnO1xuXG5pbnRlcmZhY2UgTG9jYWxMaWJyYXJ5UmVmIHtcbiAgICBjb2RlOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGFkZGVkQXQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsTGlicmFyaWVzKCk6IExvY2FsTGlicmFyeVJlZltdIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSk7XG4gICAgICAgIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiBbXTtcbiAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVMaWJyYXJ5VG9Mb2NhbChjb2RlOiBzdHJpbmcsIG5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGxpYnJhcmllcyA9IGdldExvY2FsTGlicmFyaWVzKCkuZmlsdGVyKGwgPT4gbC5jb2RlICE9PSBjb2RlLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICBsaWJyYXJpZXMudW5zaGlmdCh7IGNvZGU6IGNvZGUudG9VcHBlckNhc2UoKSwgbmFtZSwgYWRkZWRBdDogRGF0ZS5ub3coKSB9KTtcbiAgICAgICAgLy8gS2VlcCBvbmx5IHRoZSBsYXN0IDEwIGxpYnJhcmllc1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkobGlicmFyaWVzLnNsaWNlKDAsIDEwKSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyB0byBsb2NhbCBzdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMaWJyYXJ5RnJvbUxvY2FsKGNvZGU6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGxpYnJhcmllcyA9IGdldExvY2FsTGlicmFyaWVzKCkuZmlsdGVyKGwgPT4gbC5jb2RlICE9PSBjb2RlLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkobGlicmFyaWVzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgZnJvbSBsb2NhbCBzdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG59XG5cbi8vIFZlcmlmeSBwYXNzd29yZCBmb3IgYSBsaWJyYXJ5XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5TGlicmFyeVBhc3N3b3JkKGNvZGU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGxpYnJhcnkgPSBhd2FpdCBnZXRMaWJyYXJ5KGNvZGUpO1xuICAgIGlmICghbGlicmFyeSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghbGlicmFyeS5wYXNzd29yZEhhc2gpIHJldHVybiB0cnVlOyAvLyBObyBwYXNzd29yZCByZXF1aXJlZFxuICAgIHJldHVybiBzaW1wbGVIYXNoKHBhc3N3b3JkKSA9PT0gbGlicmFyeS5wYXNzd29yZEhhc2g7XG59XG4iXSwibmFtZXMiOlsiZGJSZWYiLCJzZXQiLCJnZXQiLCJ1cGRhdGUiLCJyZW1vdmUiLCJzaW1wbGVIYXNoIiwic3RyIiwiaGFzaCIsImkiLCJsZW5ndGgiLCJjaGFyIiwiY2hhckNvZGVBdCIsIk1hdGgiLCJhYnMiLCJ0b1N0cmluZyIsImdlbmVyYXRlTGlicmFyeUNvZGUiLCJjaGFycyIsImNvZGUiLCJjaGFyQXQiLCJmbG9vciIsInJhbmRvbSIsImNyZWF0ZUxpYnJhcnkiLCJuYW1lIiwicHJvbXB0cyIsInBhc3N3b3JkIiwibGlicmFyeSIsImlkIiwidHJpbSIsInBhc3N3b3JkSGFzaCIsInVuZGVmaW5lZCIsImNyZWF0ZWRBdCIsIkRhdGUiLCJub3ciLCJ1cGRhdGVkQXQiLCJmaWx0ZXIiLCJwIiwicGxheUNvdW50Iiwic2F2ZUxpYnJhcnlUb0xvY2FsIiwic3VjY2VzcyIsImVycm9yIiwiY29uc29sZSIsImdldExpYnJhcnkiLCJzbmFwc2hvdCIsInRvVXBwZXJDYXNlIiwiZXhpc3RzIiwidmFsIiwidXBkYXRlTGlicmFyeSIsInVwZGF0ZXMiLCJ1cGRhdGVEYXRhIiwiaW5jcmVtZW50UGxheUNvdW50IiwiZGVsZXRlTGlicmFyeSIsInJlbW92ZUxpYnJhcnlGcm9tTG9jYWwiLCJMT0NBTF9TVE9SQUdFX0tFWSIsImdldExvY2FsTGlicmFyaWVzIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsImxpYnJhcmllcyIsImwiLCJ1bnNoaWZ0IiwiYWRkZWRBdCIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJzbGljZSIsInZlcmlmeUxpYnJhcnlQYXNzd29yZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/customPrompts.ts\n"));

/***/ })

}]);